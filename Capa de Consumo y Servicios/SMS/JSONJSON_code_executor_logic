# Código fuente implementado en la función Lambda SMSConsumerLambda

import json
import boto3
import os
import time

# Clientes
sqs = boto3.client('sqs')
dynamodb = boto3.resource('dynamodb')
# sns = boto3.client('sns')  <-- (Comentado por bloqueo de cuenta nueva)

TABLE_NAME = os.environ['DYNAMODB_TABLE']
table = dynamodb.Table(TABLE_NAME)

def lambda_handler(event, context):
    print(f"Procesando lote de {len(event['Records'])} mensajes SMS.")
    
    batch_item_failures = []

    for record in event['Records']:
        message_id = record['messageId']
        try:
            # 1. Parsear el mensaje
            body = json.loads(record['body'])
            
            # Datos esperados para SMS
            phone_number = body.get('phone_number')
            message_content = body.get('message', 'Sin contenido')
            # Usamos ID del mensaje SQS si no viene uno en el evento
            notification_id = body.get('id', message_id)

            if not phone_number:
                print("Falta número de teléfono, omitiendo.")
                continue

            # 2. ENVÍO SIMULADO (MOCK)
            # ---------------------------------------------------------
            # Aquí iría: response = sns.publish(PhoneNumber=phone_number, Message=message_content)
            # Pero simulamos una respuesta exitosa de SNS:
            print(f" SIMULACIÓN: Enviando SMS a {phone_number} con texto: '{message_content}'")
            fake_sns_id = f"mock-sns-id-{int(time.time())}"
            # ---------------------------------------------------------

            # 3. Auditoría en DynamoDB (REAL)
            # Esto dejará prueba en la base de datos de que el sistema procesó el pedido
            audit_item = {
                'NotificationsID': notification_id,
                'Timestamp': str(time.time()),
                'Channel': 'SMS',
                'Status': 'SENT_MOCK',  # Estado especial para identificar pruebas
                'Recipient': phone_number,
                'SESMessageId': fake_sns_id
            }
            table.put_item(Item=audit_item)
            print(f"Auditoría registrada para {notification_id}")

        except Exception as e:
            print(f"ERROR en mensaje {message_id}: {str(e)}")
            batch_item_failures.append({"itemIdentifier": message_id})

    return {
        "batchItemFailures": batch_item_failures
    }
